{
  "language": "Solidity",
  "sources": {
    "src/PRS.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.12;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { Counters } from \"@openzeppelin/contracts/utils/Counters.sol\";\nimport { Strings } from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport { Errors } from \"./Errors.sol\";\nimport { TaxableGame } from \"./TaxableGame.sol\";\nimport { ITablelandTables } from \"@tableland/evm/contracts/ITablelandTables.sol\";\n\n//                                       .::^^^^::..\n//                              .:^!?YPG##&&$$$$$&&#BP5J7~:\n//                          .!PB#&$$$$$$$$$$$$$$$$$$$$$$$$&BPJ!:\n//                       .!5#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&BY^\n//                    .!5&$$$$$$$$$$$$$$$$$#BB##&$$$$$$$$$$$$$$$$$$P^\n//                  ~5#$$$$$$$$$$$$#G5YJ?!^.  ...:^!?5G#$$$$$$$$$$$$$Y:\n//                !G$$$$$$$$$$$#57^.                   .~?G&$$$$$$$$$$&J.\n//              ^G$$$$$$$$$$&P!.                           :?B$$$$$$$$$$#!\n//             J$$$$$$$$$$#J:                                 !B$$$$$$$$$$5.\n//           .P$$$$$$$$$#?.                                     ?&$$$$$$$$$G.\n//          :G$$$$$$$$&?.              .                         :G$$$$$$$$$Y\n//         ~#$$$$$$$$5:             .Y##Y.                         5$$$$$$$$&:\n//        Y$$$$$$$$$?              :#$$$$?      .?YJ^               P$$$$$$$$5\n//       ~$$$$$$$$$?               Y$$$$$Y     ^B$$$$!              .#$$$$$$$$^\n//       P$$$$$$$$?     ~!^.       P$$$$$?     B$$$$$7               J$$$$$$$$J\n//      7$$$$$$$$5     ^$$$#BB##Y  !$$$$G      B$$$$G                ^$$$$$$$$J\n//     ^$$$$$$$$&.      J$$$$$$&Y   7GGY.      Y$$$G.                :&$$$$$$$!\n//     Y$$$$$$$$G        7$$$$?.               .JP?    !J!~!??^      ^$$$$$$$$^\n//     7$$$$$$$$#.       :$$$$^                       ?$$$$$$$$~     ?$$$$$$$$^\n//     :&$$$$$$$$~        G$$$#:                      .5$$$$$#Y:     B$$$$$$$&:\n//     .#$$$$$$$$7        ^&$$$#^                     .B$$$$J.      7$$$$$$$$?\n//      5$$$$$$$#.         ^#$$$&7                   .G$$$$!       :#$$$$$$$J\n//      !$$$$$$$#^          :P$$$$P~               .?#$$$$!        G$$$$$$$Y\n//      .#$$$$$$$&!           !B$$$$BJ~:      .:~?P&$$$$G~       .P$$$$$$$P\n//       Y$$$$$$$$$7            !P&$$$$&#GPPPG#&$$$$$$P~        :G$$$$$$$B.\n//       :&$$$$$$$$$?             :!YG&$$$$$$$$$$$&GJ^         ?&$$$$$$$#:\n//        7$$$$$$$$$$Y.               .^~7??7!~!!~:         .7B$$$$$$$$G:\n//         ~B$$$$$$$$$B!                                  ^J#$$$$$$$$&J\n//           J$$$$$$$$$$BJ~.                           ^JB$$$$$$$$$$P^\n//            ^G$$$$$$$$$$$#P?^.                   :!YB$$$$$$$$$$$#!\n//              ?&$$$$$$$$$$$$$#G5?!^:.  .:~7??J5P#&$$$$$$$$$$$&G?.\n//               .J#$$$$$$$$$$$$$$$$$&#BB#&$$$$$$$$$$$$$$$$$$G7.\n//                 .7P#$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&G?^\n//                    .^7J5G#$$$$$$$$$$$$$$$$$$$$$$$$&B57:\n//                          .^7YPB#&&&$$$&&&&##BG5J7~:\n//                                ..::::::::...\n//\n\n/// @title PAPER, ROCK, SCISSORS\n/// @author DOPE DAO\n/// @notice A competitive, token-based, on-chain game of skill that persists results to\n///         a public leaderboard stored in tableland.\ncontract PRS is Ownable(), Pausable(), TaxableGame {\n    enum Choices {\n        NONE,\n        ROCK,\n        PAPER,\n        SCISSORS,\n        INVALID\n    }\n\n    struct Game {\n        bytes32 p1SaltedChoice;\n        bytes32 encChoice;\n        Choices p1ClearChoice;\n        Choices p2ClearChoice;\n        address p1;\n        address p2;\n        uint256 entryFee;\n        uint256 timerStart;\n        bool resolved;\n    }\n\n    /// Both players have 12 hours to reveal their move.\n    /// If one of them fails to do so the other can take the pot.\n    uint256 public revealTimeout = 12 hours;\n    using Counters for Counters.Counter;\n    Counters.Counter private _games;\n    mapping(uint256 => Game) Games;\n\n    ITablelandTables private _tableland;\n    uint256 private _gameTableId;\n    string private _gameTable;\n    string private _tablePrefix = \"prs\";\n\n    event CreatedGame(address indexed, uint256, uint256);\n    event JoinedGameOf(address indexed, address indexed, uint256, uint256, uint256);\n    event WonGameAgainst(address indexed, Choices, address indexed, Choices, uint256, uint256);\n    event GameDraw(address indexed, Choices, address indexed, Choices, uint256, uint256);\n\n    /// Create tableland schema for our leaderboard.\n    /// @param tablelandRegistry Address of the \"tableland registry\" on the chain this will be deployed on\n    /// @dev Find the list of tableland registries here https://docs.tableland.xyz/limits-and-deployed-contracts#ae3cfc1cfd2941bfa401580aa1e05c5e\n    constructor(address tablelandRegistry) {\n        _createTable(tablelandRegistry);\n    }\n\n    function setRevealTimeout(uint256 newTimeout) public onlyOwner {\n        revealTimeout = newTimeout;\n    }\n\n    /// Returns a single game for Player 1\n    /// @return Game struct\n    function getGame(uint256 gameId) public view returns (Game memory) {\n        Game storage game = Games[gameId];\n        if (game.p1 == address(0)) revert Errors.IndexOutOfBounds(gameId);\n\n        return game;\n    }\n\n    /// Return time left after Player 2 has revealed their move.\n    function getTimeLeft(uint256 gameId) public view returns (uint256) {\n        Game memory game = getGame(gameId);\n        if (_didTimerRunOut(game.timerStart)) revert Errors.TimerFinished();\n        if (game.p2 == address(0)) revert Errors.NoActiveTimer();\n        return revealTimeout - (block.timestamp - game.timerStart);\n    }\n\n    /// @return Entry fee for a game id. 1/2 the \"pot\"\n    function getGameEntryFee(uint256 gameId) public view returns (uint256) {\n        Game memory game = getGame(gameId);\n        return game.entryFee;\n    }\n\n    /// Pause game in case of suspicious activity\n    function pauseGame() public onlyOwner {\n        _pause();\n    }\n\n    /// Unpause game\n    function unpauseGame() public onlyOwner {\n        _unpause();\n    }\n\n    /* ========================================================================================= */\n    // Commit\n    /* ========================================================================================= */\n\n    /// Whoever calls this makes a new game and becomes \"p1\"\n    /// Requires a sha256 encoded move and password to be stored as\n    /// A player can make multiple games at a time.\n    ///\n    /// @param encChoice sha256 hashed move and password\n    /// @param entryFee The amount of entry fee required for this game.\n    function startGame(bytes32 encChoice, uint256 entryFee)\n        public\n        checkEntryFeeEnough(entryFee)\n        checkAddressHasSufficientBalance(entryFee)\n        whenNotPaused\n    {\n        Game storage game = Games[_games.current()];\n        _games.increment();\n\n        game.p1 = msg.sender;\n        game.entryFee = entryFee;\n        game.p1SaltedChoice = encChoice;\n\n        _subtractFromBalance(msg.sender, entryFee);\n        emit CreatedGame(msg.sender, entryFee, block.timestamp);\n    }\n\n    /// Allows p2 to join an existing game by gameId\n    /// Requires player to commit their hashed move and password to join.\n    /// Will fail if player does not have high enough balance on contract.\n    ///\n    /// @param gameId ID of game stored in local storage.\n    /// @param encChoice sha256 hashed move and password\n    /// @param entryFee The amount of entry fee required for this game.\n    function joinGame(\n        uint256 gameId,\n        bytes32 encChoice,\n        uint256 entryFee\n    ) public checkAddressHasSufficientBalance(entryFee) whenNotPaused {\n        Game storage game = Games[gameId];\n        address player1 = game.p1;\n\n        if (player1 == address(0)) revert Errors.IndexOutOfBounds(gameId);\n        if (player1 == msg.sender) revert Errors.CannotJoinGame(false, true);\n        if (game.p2 != address(0)) revert Errors.CannotJoinGame(true, false);\n        if (entryFee < game.entryFee) revert Errors.AmountTooLow(entryFee, game.entryFee);\n\n        game.p2 = msg.sender;\n        game.encChoice = encChoice;\n        game.timerStart = block.timestamp;\n\n        _subtractFromBalance(msg.sender, entryFee);\n        emit JoinedGameOf(msg.sender, player1, gameId, entryFee, block.timestamp);\n    }\n\n    /* ========================================================================================= */\n    // Reveal\n    /* ========================================================================================= */\n\n    function revealChoice(uint256 gameId, string calldata movePw) public whenNotPaused {\n        Game storage game = Games[gameId];\n        address player1 = game.p1;\n        address player2 = game.p2;\n\n        if (player1 == address(0)) revert Errors.IndexOutOfBounds(gameId);\n        if (player2 == address(0)) revert Errors.NoSecondPlayer();\n\n        if (msg.sender == player1) {\n            if (game.p1ClearChoice != Choices.NONE)\n                revert Errors.AlreadyRevealed(msg.sender, gameId);\n            game.p1ClearChoice = _getHashChoice(game.p1SaltedChoice, movePw);\n            return;\n        }\n\n        if (msg.sender == player2) {\n            if (game.p2ClearChoice != Choices.NONE)\n                revert Errors.AlreadyRevealed(msg.sender, gameId);\n            game.p2ClearChoice = _getHashChoice(game.encChoice, movePw);\n            return;\n        }\n    }\n\n    /* ========================================================================================= */\n    // Resolve\n    /* ========================================================================================= */\n\n    /// @dev Game is not resolvable if timer is still running and both players\n    ///      have not revealed their move.\n    function resolveGame(uint256 gameId) public whenNotPaused {\n        Game storage game = Games[gameId];\n        if (game.p1 == address(0)) revert Errors.IndexOutOfBounds(gameId);\n        if (game.p2 == address(0)) revert Errors.NoSecondPlayer();\n        if (game.resolved) revert Errors.NotResolvable(false, false, false, true);\n\n        bool isTimerRunning = !_didTimerRunOut(game.timerStart);\n        bool isP1ChoiceNone = game.p1ClearChoice == Choices.NONE;\n        bool isP2ChoiceNone = game.p2ClearChoice == Choices.NONE;\n\n        if (isTimerRunning && (isP2ChoiceNone || isP1ChoiceNone))\n            revert Errors.NotResolvable(isTimerRunning, isP1ChoiceNone, isP2ChoiceNone, false);\n        uint256 gameBalance = game.entryFee * 2;\n\n        /// Prevent re-entrancy.\n        game.resolved = true;\n\n        // If we are here that means both players revealed their move.\n        // If both revealed their move in time we can choose a winner.\n        if (isTimerRunning) {\n            _chooseWinner(game.p1ClearChoice, game.p2ClearChoice, game.p1, game.p2, gameBalance);\n            return;\n        }\n\n        // Timer ran out and only p2 did not reveal\n        if (!isTimerRunning && !isP1ChoiceNone && isP2ChoiceNone) {\n            _payout(game.p1, gameBalance);\n            return;\n        }\n\n        // Timer ran out and only p1 did not reveal\n        if (!isTimerRunning && isP1ChoiceNone && !isP2ChoiceNone) {\n            _payout(game.p2, gameBalance);\n            return;\n        }\n        // If both players fail to reveal the entryFee gets \"burned\" ;)\n    }\n\n    /* ========================================================================================= */\n    // Internals\n    /* ========================================================================================= */\n\n    /// How PRS chooses a winner when two choices are revealed.\n    /// @dev Essential that you ZERO OUT ANY GAME BALANCES before calling this.\n    function _chooseWinner(\n        Choices p1Choice,\n        Choices p2Choice,\n        address p1,\n        address p2,\n        uint256 gameBalance\n    ) internal {\n        if (p1Choice == p2Choice) {\n            _payout(p1, gameBalance / 2);\n            _payout(p2, gameBalance / 2);\n            emit GameDraw(p1, p1Choice, p2, p2Choice, gameBalance, block.timestamp);\n            return;\n        }\n\n        if (\n            (p1Choice == Choices.PAPER && p2Choice == Choices.ROCK) ||\n            (p1Choice == Choices.ROCK && p2Choice == Choices.SCISSORS) ||\n            (p1Choice == Choices.SCISSORS && p2Choice == Choices.PAPER)\n        ) {\n            _payout(p1, gameBalance);\n            emit WonGameAgainst(p1, p1Choice, p2, p2Choice, gameBalance, block.timestamp);\n            return;\n        }\n\n        if (p1Choice == Choices.INVALID) {\n            _payout(p2, gameBalance);\n            emit WonGameAgainst(p2, p2Choice, p1, p1Choice, gameBalance, block.timestamp);\n            return;\n        }\n\n        if (p2Choice == Choices.INVALID) {\n            _payout(p1, gameBalance);\n            emit WonGameAgainst(p1, p1Choice, p2, p2Choice, gameBalance, block.timestamp);\n            return;\n        }\n\n        _payout(p2, gameBalance);\n        emit WonGameAgainst(p2, p2Choice, p1, p1Choice, gameBalance, block.timestamp);\n    }\n\n    function _didTimerRunOut(uint256 timerStart) internal view returns (bool) {\n        return block.timestamp > timerStart + revealTimeout;\n    }\n\n    function _getHashChoice(bytes32 hashChoice, string calldata clearChoice)\n        internal\n        pure\n        returns (Choices)\n    {\n        bytes32 hashedClearChoice = sha256(abi.encodePacked(clearChoice));\n        if (hashChoice != hashedClearChoice) revert Errors.InvalidPassword();\n\n        bytes1 first = bytes(clearChoice)[0];\n\n        if (first == 0x31) {\n            return Choices.ROCK;\n        } else if (first == 0x32) {\n            return Choices.PAPER;\n        } else if (first == 0x33) {\n            return Choices.SCISSORS;\n        }\n\n        return Choices.INVALID;\n    }\n\n    /// Initializes Tableland table to store record of games played.\n    /// @param tablelandRegistry Address of the \"tableland registry\" on the chain this will be deployed on\n    /// @dev Abstracted out to a function so inherited contract can call this for testing.\n    function _createTable(address tablelandRegistry) internal {\n        _tableland = ITablelandTables(tablelandRegistry);\n\n        /// @dev See tableland docs for more info\n        string memory tableColumns = \"(\"\n            \"game_id INTEGER UNIQUE, \"\n            \"created_at_timestamp INTEGER, \"\n            \"game_entry_fee INTEGER, \"\n            \"player_1 TEXT, \"\n            \"player_2 TEXT, \"\n            \"winner TEXT, \"\n            \"player_1_move INTEGER, \"\n            \"player_2_move INTEGER \"\n        \");\";\n\n        /// @dev Stores unique ID for our created table\n        _gameTableId = _tableland.createTable(\n            address(this),\n            string.concat(\n                \"CREATE TABLE\",\n                _tablePrefix,\n                \"_\",\n                Strings.toString(block.chainid),\n                \" \",\n                tableColumns\n            )\n        );\n\n        /// @dev Stores full table name for new table.\n        _gameTable = string.concat(\n            _tablePrefix,\n            \"_\",\n            Strings.toString(block.chainid),\n            \"_\",\n            Strings.toString(_gameTableId)\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "src/Errors.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.12;\n\nlibrary Errors {\n    error AmountTooLow(uint256 available, uint256 required);\n    error CannotJoinGame(bool alreadHasP2, bool tryingToJoinOwnGame);\n    error InvalidBalance(uint256 balance);\n    error IndexOutOfBounds(uint256 gameId);\n    error InvalidPassword();\n    error NoActiveTimer();\n    error NoSecondPlayer();\n    error NotEnoughMoneyInContract(uint256 available, uint256 requested);\n    error NotSecondPlayer(address expected, address received);\n    error PlayerBalanceNotEnough(uint256 available, uint256 required);\n    error TimerFinished();\n    error TimerStillRunning();\n    error AlreadyRevealed(address player, uint256 gameId);\n    error NotResolvable(bool timerStillRunning, bool p1Revealed, bool p2Revealed, bool alreadyResolved);\n}\n"
    },
    "src/TaxableGame.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.12;\n\nimport { Errors } from \"./Errors.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n// @notice Abstract contract to handle fees, taxes, balances, and payouts of players\nabstract contract TaxableGame is Ownable, ReentrancyGuard, Pausable {\n    // @notice Variable minimum entry fee in gwei\n    uint256 public minEntryFee = 10000000 gwei; // 0.01 eth\n    // @notice Tax percent the game takes for each round of play\n    uint256 public taxPercent = 5;\n\n    // @notice Where we keep balances of players and the contract itself\n    mapping(address => uint256) internal _balances;\n\n    event PaidOut(address indexed, uint256, uint256);\n\n    // @notice Check to determine if this address has enough balance to participate\n    modifier checkAddressHasSufficientBalance(uint256 entryFee) {\n        uint256 balance = balanceOf(msg.sender);\n        if (balance < entryFee) revert Errors.PlayerBalanceNotEnough(balance, entryFee);\n        _;\n    }\n\n    modifier checkEntryFeeEnough(uint256 entryFee) {\n        if (entryFee < minEntryFee) revert Errors.AmountTooLow(entryFee, minEntryFee);\n        _;\n    }\n\n    /* ========================================================================================= */\n    // Receiving and withdrawing\n    /* ========================================================================================= */\n\n    // @notice Players increase their balance by sending the contract tokens\n    receive() external payable {\n        _addToBalance(msg.sender, msg.value);\n    }\n\n    // @notice Players can withdraw their balance from the contract\n    function withdraw() public payable whenNotPaused {\n        uint256 balance = balanceOf(msg.sender);\n        if (address(this).balance < balance) revert Errors.NotEnoughMoneyInContract(address(this).balance, balance);\n        _setBalance(msg.sender, 0);\n        payable(msg.sender).transfer(balance);\n    }\n\n    // @notice Withdraws tax from games played to contract owner\n    function withdrawTax() public payable onlyOwner {\n        uint256 balance = balanceOf(address(this));\n        if (address(this).balance < balance) revert Errors.NotEnoughMoneyInContract(address(this).balance, balance);\n        _setBalance(address(this), 0);\n        payable(msg.sender).transfer(balance);\n    }\n\n    /* ========================================================================================= */\n    // Fees and taxes\n    /* ========================================================================================= */\n    function setMinEntryFee(uint256 fee) public onlyOwner {\n        minEntryFee = fee;\n    }\n\n    function setTaxPercent(uint256 pct) public onlyOwner {\n        taxPercent = pct;\n    }\n\n    /* ========================================================================================= */\n    // Balances\n    /* ========================================================================================= */\n\n    // @notice Entire balance of contract\n    function getBalance() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    // @notice Balance for players and this contract itself\n    function balanceOf(address account) public view returns (uint256) {\n        return _balances[account];\n    }\n\n    function _addToBalance(address account, uint256 amount) internal {\n        uint256 currentBalance = balanceOf(account);\n        uint256 newBalance = currentBalance + amount;\n        _setBalance(account, newBalance);\n    }\n\n    function _subtractFromBalance(address account, uint256 amount) internal {\n        uint256 currentBalance = balanceOf(account);\n        uint256 newBalance = currentBalance - amount;\n        if (0 >= newBalance) {\n            newBalance = 0;\n        }\n        _setBalance(account, newBalance);\n    }\n\n    function _setBalance(address account, uint256 balance) internal {\n        if (balance < 0) revert Errors.InvalidBalance(balance);\n        _balances[account] = balance;\n    }\n\n    /* ========================================================================================= */\n    // Payments\n    /* ========================================================================================= */\n    \n    // @return payout Amount paid to player less tax\n    // @return tax    Amount taxed from payout\n    function _getPayoutWithTax(uint256 amount) internal view returns (uint256, uint256) {\n        uint256 tax = (amount / 100) * taxPercent;\n        uint256 payout = amount - tax;\n        return (payout, tax);\n    }\n\n    // @notice A simple, and slightly UNSAFE payout function.\n    //         Ensure that you're setting balances to zero wherever this is called.\n    function _payout(address player, uint256 amount) internal {\n        (uint256 payout, uint256 tax) = _getPayoutWithTax(amount);\n\n        _addToBalance(address(this), tax);\n        _addToBalance(player, payout);\n\n        emit PaidOut(player, payout, block.timestamp);\n    }\n}\n"
    },
    "@tableland/evm/contracts/ITablelandTables.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ITablelandController.sol\";\n\n/**\n * @dev Interface of a TablelandTables compliant contract.\n */\ninterface ITablelandTables {\n    /**\n     * The caller is not authorized.\n     */\n    error Unauthorized();\n\n    /**\n     * RunSQL was called with a query length greater than maximum allowed.\n     */\n    error MaxQuerySizeExceeded(uint256 querySize, uint256 maxQuerySize);\n\n    /**\n     * @dev Emitted when `owner` creates a new table.\n     *\n     * owner - the to-be owner of the table\n     * tableId - the table id of the new table\n     * statement - the SQL statement used to create the table\n     */\n    event CreateTable(address owner, uint256 tableId, string statement);\n\n    /**\n     * @dev Emitted when a table is transferred from `from` to `to`.\n     *\n     * Not emmitted when a table is created.\n     * Also emitted after a table has been burned.\n     *\n     * from - the address that transfered the table\n     * to - the address that received the table\n     * tableId - the table id that was transferred\n     */\n    event TransferTable(address from, address to, uint256 tableId);\n\n    /**\n     * @dev Emitted when `caller` runs a SQL statement.\n     *\n     * caller - the address that is running the SQL statement\n     * isOwner - whether or not the caller is the table owner\n     * tableId - the id of the target table\n     * statement - the SQL statement to run\n     * policy - an object describing how `caller` can interact with the table (see {ITablelandController.Policy})\n     */\n    event RunSQL(\n        address caller,\n        bool isOwner,\n        uint256 tableId,\n        string statement,\n        ITablelandController.Policy policy\n    );\n\n    /**\n     * @dev Emitted when a table's controller is set.\n     *\n     * tableId - the id of the target table\n     * controller - the address of the controller (EOA or contract)\n     */\n    event SetController(uint256 tableId, address controller);\n\n    /**\n     * @dev Creates a new table owned by `owner` using `statement` and returns its `tableId`.\n     *\n     * owner - the to-be owner of the new table\n     * statement - the SQL statement used to create the table\n     *\n     * Requirements:\n     *\n     * - contract must be unpaused\n     */\n    function createTable(address owner, string memory statement)\n        external\n        payable\n        returns (uint256);\n\n    /**\n     * @dev Runs a SQL statement for `caller` using `statement`.\n     *\n     * caller - the address that is running the SQL statement\n     * tableId - the id of the target table\n     * statement - the SQL statement to run\n     *\n     * Requirements:\n     *\n     * - contract must be unpaused\n     * - `msg.sender` must be `caller` or contract owner\n     * - `tableId` must exist\n     * - `caller` must be authorized by the table controller\n     * - `statement` must be less than or equal to 35000 bytes\n     */\n    function runSQL(\n        address caller,\n        uint256 tableId,\n        string memory statement\n    ) external payable;\n\n    /**\n     * @dev Sets the controller for a table. Controller can be an EOA or contract address.\n     *\n     * When a table is created, it's controller is set to the zero address, which means that the\n     * contract will not enforce write access control. In this situation, validators will not accept\n     * transactions from non-owners unless explicitly granted access with \"GRANT\" SQL statements.\n     *\n     * When a controller address is set for a table, validators assume write access control is\n     * handled at the contract level, and will accept all transactions.\n     *\n     * You can unset a controller address for a table by setting it back to the zero address.\n     * This will cause validators to revert back to honoring owner and GRANT bases write access control.\n     *\n     * caller - the address that is setting the controller\n     * tableId - the id of the target table\n     * controller - the address of the controller (EOA or contract)\n     *\n     * Requirements:\n     *\n     * - contract must be unpaused\n     * - `msg.sender` must be `caller` and owner of `tableId`\n     * - `tableId` must exist\n     * - `tableId` controller must not be locked\n     */\n    function setController(\n        address caller,\n        uint256 tableId,\n        address controller\n    ) external;\n\n    /**\n     * @dev Returns the controller for a table.\n     *\n     * tableId - the id of the target table\n     */\n    function getController(uint256 tableId) external returns (address);\n\n    /**\n     * @dev Locks the controller for a table _forever_. Controller can be an EOA or contract address.\n     *\n     * Although not very useful, it is possible to lock a table controller that is set to the zero address.\n     *\n     * caller - the address that is locking the controller\n     * tableId - the id of the target table\n     *\n     * Requirements:\n     *\n     * - contract must be unpaused\n     * - `msg.sender` must be `caller` and owner of `tableId`\n     * - `tableId` must exist\n     * - `tableId` controller must not be locked\n     */\n    function lockController(address caller, uint256 tableId) external;\n\n    /**\n     * @dev Sets the contract base URI.\n     *\n     * baseURI - the new base URI\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be contract owner\n     */\n    function setBaseURI(string memory baseURI) external;\n\n    /**\n     * @dev Pauses the contract.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be contract owner\n     * - contract must be unpaused\n     */\n    function pause() external;\n\n    /**\n     * @dev Unpauses the contract.\n     *\n     * Requirements:\n     *\n     * - `msg.sender` must be contract owner\n     * - contract must be paused\n     */\n    function unpause() external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@tableland/evm/contracts/ITablelandController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @dev Interface of a TablelandController compliant contract.\n *\n * This interface can be implemented to enabled advanced access control for a table.\n * Call {ITablelandTables-setController} with the address of your implementation.\n *\n * See {test/TestTablelandController} for an example of token-gating table write-access.\n */\ninterface ITablelandController {\n    /**\n     * @dev Object defining how a table can be accessed.\n     */\n    struct Policy {\n        // Whether or not the table should allow SQL INSERT statements.\n        bool allowInsert;\n        // Whether or not the table should allow SQL UPDATE statements.\n        bool allowUpdate;\n        // Whether or not the table should allow SQL DELETE statements.\n        bool allowDelete;\n        // A conditional clause used with SQL UPDATE and DELETE statements.\n        // For example, a value of \"foo > 0\" will concatenate all SQL UPDATE\n        // and/or DELETE statements with \"WHERE foo > 0\".\n        // This can be useful for limiting how a table can be modified.\n        // Use {Policies-joinClauses} to include more than one condition.\n        string whereClause;\n        // A conditional clause used with SQL INSERT statements.\n        // For example, a value of \"foo > 0\" will concatenate all SQL INSERT\n        // statements with a check on the incoming data, i.e., \"CHECK (foo > 0)\".\n        // This can be useful for limiting how table data ban be added.\n        // Use {Policies-joinClauses} to include more than one condition.\n        string withCheck;\n        // A list of SQL column names that can be updated.\n        string[] updatableColumns;\n    }\n\n    /**\n     * @dev Returns a {Policy} struct defining how a table can be accessed by `caller`.\n     */\n    function getPolicy(address caller) external payable returns (Policy memory);\n}\n"
    },
    "src/mocks/PRSMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport { PRS } from \"../PRS.sol\";\n\ncontract PRSMock is PRS {\n    constructor(address tablelandRegistry) PRS(tablelandRegistry) {\n    }\n\n    function unsafeChooseWinner(\n        Choices p1Choice,\n        Choices p2Choice,\n        address p1,\n        address p2,\n        uint256 entryFee\n    ) public {\n        return _chooseWinner(p1Choice, p2Choice, p1, p2, entryFee);\n    }\n\n    function unsafeDidTimerRunOut(uint256 timerStart) public view returns (bool) {\n        return _didTimerRunOut(timerStart);\n    }\n\n    function unsafeGetHashChoice(bytes32 hashChoice, string calldata clearChoice)\n        public\n        pure\n        returns (Choices) {\n        return _getHashChoice(hashChoice, clearChoice);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}